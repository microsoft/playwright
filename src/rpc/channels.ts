/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is generated by generate_channels.js, do not edit manually.

import { EventEmitter } from 'events';

export type Binary = string;

export interface Channel extends EventEmitter {
}

export type SerializedValue = {
  n?: number,
  b?: boolean,
  s?: string,
  v?: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0',
  d?: string,
  r?: {
    p: string,
    f: string,
  },
  a?: SerializedValue[],
  o?: {
    k: string,
    v: SerializedValue,
  }[],
  h?: number,
};

export type SerializedArgument = {
  value: SerializedValue,
  handles: Channel[],
};

export type AXNode = {
  role: string,
  name: string,
  valueString?: string,
  valueNumber?: number,
  description?: string,
  keyshortcuts?: string,
  roledescription?: string,
  valuetext?: string,
  disabled?: boolean,
  expanded?: boolean,
  focused?: boolean,
  modal?: boolean,
  multiline?: boolean,
  multiselectable?: boolean,
  readonly?: boolean,
  required?: boolean,
  selected?: boolean,
  checked?: 'checked' | 'unchecked' | 'mixed',
  pressed?: 'pressed' | 'released' | 'mixed',
  level?: number,
  valuemin?: number,
  valuemax?: number,
  autocomplete?: string,
  haspopup?: string,
  invalid?: string,
  orientation?: string,
  children?: AXNode[],
};

export type SerializedError = {
  error?: {
    message: string,
    name: string,
    stack?: string,
  },
  value?: SerializedValue,
};

// ----------- Playwright -----------
export type PlaywrightInitializer = {
  chromium: BrowserTypeChannel,
  firefox: BrowserTypeChannel,
  webkit: BrowserTypeChannel,
  electron?: ElectronChannel,
  deviceDescriptors: {
    name: string,
    descriptor: {
      userAgent: string,
      viewport: {
        width: number,
        height: number,
      },
      deviceScaleFactor: number,
      isMobile: boolean,
      hasTouch: boolean,
    },
  }[],
  selectors: SelectorsChannel,
};
export interface PlaywrightChannel extends Channel {
}

// ----------- Selectors -----------
export type SelectorsInitializer = {};
export interface SelectorsChannel extends Channel {
  register(params: SelectorsRegisterParams): Promise<SelectorsRegisterResult>;
  createSelector(params: SelectorsCreateSelectorParams): Promise<SelectorsCreateSelectorResult>;
}
export type SelectorsRegisterParams = {
  name: string,
  source: string,
  contentScript?: boolean,
};
export type SelectorsRegisterResult = void;
export type SelectorsCreateSelectorParams = {
  name: string,
  handle: ElementHandleChannel,
};
export type SelectorsCreateSelectorResult = {
  value?: string,
};

// ----------- BrowserType -----------
export type BrowserTypeInitializer = {
  executablePath: string,
  name: string,
};
export interface BrowserTypeChannel extends Channel {
  connect(params: BrowserTypeConnectParams): Promise<BrowserTypeConnectResult>;
  launch(params: BrowserTypeLaunchParams): Promise<BrowserTypeLaunchResult>;
  launchServer(params: BrowserTypeLaunchServerParams): Promise<BrowserTypeLaunchServerResult>;
  launchPersistentContext(params: BrowserTypeLaunchPersistentContextParams): Promise<BrowserTypeLaunchPersistentContextResult>;
}
export type BrowserTypeConnectParams = {
  wsEndpoint: string,
  slowMo?: number,
  timeout?: number,
};
export type BrowserTypeConnectResult = {
  browser: BrowserChannel,
};
export type BrowserTypeLaunchParams = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: {
    name: string,
    value: string,
  }[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  slowMo?: number,
};
export type BrowserTypeLaunchResult = {
  browser: BrowserChannel,
};
export type BrowserTypeLaunchServerParams = {
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: {
    name: string,
    value: string,
  }[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  port?: number,
};
export type BrowserTypeLaunchServerResult = {
  server: BrowserServerChannel,
};
export type BrowserTypeLaunchPersistentContextParams = {
  userDataDir: string,
  executablePath?: string,
  args?: string[],
  ignoreAllDefaultArgs?: boolean,
  ignoreDefaultArgs?: string[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
  env?: {
    name: string,
    value: string,
  }[],
  headless?: boolean,
  devtools?: boolean,
  proxy?: {
    server: string,
    bypass?: string,
    username?: string,
    password?: string,
  },
  downloadsPath?: string,
  slowMo?: number,
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: {
    name: string,
    value: string,
  }[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
};
export type BrowserTypeLaunchPersistentContextResult = {
  context: BrowserContextChannel,
};

// ----------- BrowserServer -----------
export type BrowserServerInitializer = {
  wsEndpoint: string,
  pid: number,
};
export interface BrowserServerChannel extends Channel {
  on(event: 'close', callback: (params: BrowserServerCloseEvent) => void): this;
  close(params?: BrowserServerCloseParams): Promise<BrowserServerCloseResult>;
  kill(params?: BrowserServerKillParams): Promise<BrowserServerKillResult>;
}
export type BrowserServerCloseEvent = {};
export type BrowserServerCloseParams = {};
export type BrowserServerCloseResult = void;
export type BrowserServerKillParams = {};
export type BrowserServerKillResult = void;

// ----------- Browser -----------
export type BrowserInitializer = {};
export interface BrowserChannel extends Channel {
  on(event: 'close', callback: (params: BrowserCloseEvent) => void): this;
  close(params?: BrowserCloseParams): Promise<BrowserCloseResult>;
  newContext(params: BrowserNewContextParams): Promise<BrowserNewContextResult>;
  crNewBrowserCDPSession(params?: BrowserCrNewBrowserCDPSessionParams): Promise<BrowserCrNewBrowserCDPSessionResult>;
  crStartTracing(params: BrowserCrStartTracingParams): Promise<BrowserCrStartTracingResult>;
  crStopTracing(params?: BrowserCrStopTracingParams): Promise<BrowserCrStopTracingResult>;
}
export type BrowserCloseEvent = {};
export type BrowserCloseParams = {};
export type BrowserCloseResult = void;
export type BrowserNewContextParams = {
  noDefaultViewport?: boolean,
  viewport?: {
    width: number,
    height: number,
  },
  ignoreHTTPSErrors?: boolean,
  javaScriptEnabled?: boolean,
  bypassCSP?: boolean,
  userAgent?: string,
  locale?: string,
  timezoneId?: string,
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
  permissions?: string[],
  extraHTTPHeaders?: {
    name: string,
    value: string,
  }[],
  offline?: boolean,
  httpCredentials?: {
    username: string,
    password: string,
  },
  deviceScaleFactor?: number,
  isMobile?: boolean,
  hasTouch?: boolean,
  colorScheme?: 'dark' | 'light' | 'no-preference',
  acceptDownloads?: boolean,
};
export type BrowserNewContextResult = {
  context: BrowserContextChannel,
};
export type BrowserCrNewBrowserCDPSessionParams = {};
export type BrowserCrNewBrowserCDPSessionResult = {
  session: CDPSessionChannel,
};
export type BrowserCrStartTracingParams = {
  page?: PageChannel,
  path?: string,
  screenshots?: boolean,
  categories?: string[],
};
export type BrowserCrStartTracingResult = void;
export type BrowserCrStopTracingParams = {};
export type BrowserCrStopTracingResult = {
  binary: Binary,
};

// ----------- BrowserContext -----------
export type BrowserContextInitializer = {};
export interface BrowserContextChannel extends Channel {
  on(event: 'bindingCall', callback: (params: BrowserContextBindingCallEvent) => void): this;
  on(event: 'close', callback: (params: BrowserContextCloseEvent) => void): this;
  on(event: 'page', callback: (params: BrowserContextPageEvent) => void): this;
  on(event: 'route', callback: (params: BrowserContextRouteEvent) => void): this;
  addCookies(params: BrowserContextAddCookiesParams): Promise<BrowserContextAddCookiesResult>;
  addInitScript(params: BrowserContextAddInitScriptParams): Promise<BrowserContextAddInitScriptResult>;
  clearCookies(params?: BrowserContextClearCookiesParams): Promise<BrowserContextClearCookiesResult>;
  clearPermissions(params?: BrowserContextClearPermissionsParams): Promise<BrowserContextClearPermissionsResult>;
  close(params?: BrowserContextCloseParams): Promise<BrowserContextCloseResult>;
  cookies(params: BrowserContextCookiesParams): Promise<BrowserContextCookiesResult>;
  exposeBinding(params: BrowserContextExposeBindingParams): Promise<BrowserContextExposeBindingResult>;
  grantPermissions(params: BrowserContextGrantPermissionsParams): Promise<BrowserContextGrantPermissionsResult>;
  newPage(params?: BrowserContextNewPageParams): Promise<BrowserContextNewPageResult>;
  setDefaultNavigationTimeoutNoReply(params: BrowserContextSetDefaultNavigationTimeoutNoReplyParams): Promise<BrowserContextSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(params: BrowserContextSetDefaultTimeoutNoReplyParams): Promise<BrowserContextSetDefaultTimeoutNoReplyResult>;
  setExtraHTTPHeaders(params: BrowserContextSetExtraHTTPHeadersParams): Promise<BrowserContextSetExtraHTTPHeadersResult>;
  setGeolocation(params: BrowserContextSetGeolocationParams): Promise<BrowserContextSetGeolocationResult>;
  setHTTPCredentials(params: BrowserContextSetHTTPCredentialsParams): Promise<BrowserContextSetHTTPCredentialsResult>;
  setNetworkInterceptionEnabled(params: BrowserContextSetNetworkInterceptionEnabledParams): Promise<BrowserContextSetNetworkInterceptionEnabledResult>;
  setOffline(params: BrowserContextSetOfflineParams): Promise<BrowserContextSetOfflineResult>;
  on(event: 'crBackgroundPage', callback: (params: BrowserContextCrBackgroundPageEvent) => void): this;
  on(event: 'crServiceWorker', callback: (params: BrowserContextCrServiceWorkerEvent) => void): this;
  crNewCDPSession(params: BrowserContextCrNewCDPSessionParams): Promise<BrowserContextCrNewCDPSessionResult>;
}
export type BrowserContextBindingCallEvent = {
  binding: BindingCallChannel,
};
export type BrowserContextCloseEvent = {};
export type BrowserContextPageEvent = {
  page: PageChannel,
};
export type BrowserContextRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type BrowserContextAddCookiesParams = {
  cookies: {
    name: string,
    value: string,
    url?: string,
    domain?: string,
    path?: string,
    expires?: number,
    httpOnly?: boolean,
    secure?: boolean,
    sameSite?: 'Strict' | 'Lax' | 'None',
  }[],
};
export type BrowserContextAddCookiesResult = void;
export type BrowserContextAddInitScriptParams = {
  source: string,
};
export type BrowserContextAddInitScriptResult = void;
export type BrowserContextClearCookiesParams = {};
export type BrowserContextClearCookiesResult = void;
export type BrowserContextClearPermissionsParams = {};
export type BrowserContextClearPermissionsResult = void;
export type BrowserContextCloseParams = {};
export type BrowserContextCloseResult = void;
export type BrowserContextCookiesParams = {
  urls: string[],
};
export type BrowserContextCookiesResult = {
  cookies: {
    name: string,
    value: string,
    domain: string,
    path: string,
    expires: number,
    httpOnly: boolean,
    secure: boolean,
    sameSite: 'Strict' | 'Lax' | 'None',
  }[],
};
export type BrowserContextExposeBindingParams = {
  name: string,
};
export type BrowserContextExposeBindingResult = void;
export type BrowserContextGrantPermissionsParams = {
  permissions: string[],
  origin?: string,
};
export type BrowserContextGrantPermissionsResult = void;
export type BrowserContextNewPageParams = {};
export type BrowserContextNewPageResult = {
  page: PageChannel,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultNavigationTimeoutNoReplyResult = void;
export type BrowserContextSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type BrowserContextSetDefaultTimeoutNoReplyResult = void;
export type BrowserContextSetExtraHTTPHeadersParams = {
  headers: {
    name: string,
    value: string,
  }[],
};
export type BrowserContextSetExtraHTTPHeadersResult = void;
export type BrowserContextSetGeolocationParams = {
  geolocation?: {
    longitude: number,
    latitude: number,
    accuracy?: number,
  },
};
export type BrowserContextSetGeolocationResult = void;
export type BrowserContextSetHTTPCredentialsParams = {
  httpCredentials?: {
    username: string,
    password: string,
  },
};
export type BrowserContextSetHTTPCredentialsResult = void;
export type BrowserContextSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type BrowserContextSetNetworkInterceptionEnabledResult = void;
export type BrowserContextSetOfflineParams = {
  offline: boolean,
};
export type BrowserContextSetOfflineResult = void;
export type BrowserContextCrBackgroundPageEvent = {
  page: PageChannel,
};
export type BrowserContextCrServiceWorkerEvent = {
  worker: WorkerChannel,
};
export type BrowserContextCrNewCDPSessionParams = {
  page: PageChannel,
};
export type BrowserContextCrNewCDPSessionResult = {
  session: CDPSessionChannel,
};

// ----------- Page -----------
export type PageInitializer = {
  mainFrame: FrameChannel,
  viewportSize?: {
    width: number,
    height: number,
  },
  isClosed: boolean,
};
export interface PageChannel extends Channel {
  on(event: 'bindingCall', callback: (params: PageBindingCallEvent) => void): this;
  on(event: 'close', callback: (params: PageCloseEvent) => void): this;
  on(event: 'console', callback: (params: PageConsoleEvent) => void): this;
  on(event: 'crash', callback: (params: PageCrashEvent) => void): this;
  on(event: 'dialog', callback: (params: PageDialogEvent) => void): this;
  on(event: 'download', callback: (params: PageDownloadEvent) => void): this;
  on(event: 'domcontentloaded', callback: (params: PageDomcontentloadedEvent) => void): this;
  on(event: 'fileChooser', callback: (params: PageFileChooserEvent) => void): this;
  on(event: 'frameAttached', callback: (params: PageFrameAttachedEvent) => void): this;
  on(event: 'frameDetached', callback: (params: PageFrameDetachedEvent) => void): this;
  on(event: 'load', callback: (params: PageLoadEvent) => void): this;
  on(event: 'pageError', callback: (params: PagePageErrorEvent) => void): this;
  on(event: 'popup', callback: (params: PagePopupEvent) => void): this;
  on(event: 'request', callback: (params: PageRequestEvent) => void): this;
  on(event: 'requestFailed', callback: (params: PageRequestFailedEvent) => void): this;
  on(event: 'requestFinished', callback: (params: PageRequestFinishedEvent) => void): this;
  on(event: 'response', callback: (params: PageResponseEvent) => void): this;
  on(event: 'route', callback: (params: PageRouteEvent) => void): this;
  on(event: 'worker', callback: (params: PageWorkerEvent) => void): this;
  setDefaultNavigationTimeoutNoReply(params: PageSetDefaultNavigationTimeoutNoReplyParams): Promise<PageSetDefaultNavigationTimeoutNoReplyResult>;
  setDefaultTimeoutNoReply(params: PageSetDefaultTimeoutNoReplyParams): Promise<PageSetDefaultTimeoutNoReplyResult>;
  setFileChooserInterceptedNoReply(params: PageSetFileChooserInterceptedNoReplyParams): Promise<PageSetFileChooserInterceptedNoReplyResult>;
  addInitScript(params: PageAddInitScriptParams): Promise<PageAddInitScriptResult>;
  close(params: PageCloseParams): Promise<PageCloseResult>;
  emulateMedia(params: PageEmulateMediaParams): Promise<PageEmulateMediaResult>;
  exposeBinding(params: PageExposeBindingParams): Promise<PageExposeBindingResult>;
  goBack(params: PageGoBackParams): Promise<PageGoBackResult>;
  goForward(params: PageGoForwardParams): Promise<PageGoForwardResult>;
  opener(params?: PageOpenerParams): Promise<PageOpenerResult>;
  reload(params: PageReloadParams): Promise<PageReloadResult>;
  screenshot(params: PageScreenshotParams): Promise<PageScreenshotResult>;
  setExtraHTTPHeaders(params: PageSetExtraHTTPHeadersParams): Promise<PageSetExtraHTTPHeadersResult>;
  setNetworkInterceptionEnabled(params: PageSetNetworkInterceptionEnabledParams): Promise<PageSetNetworkInterceptionEnabledResult>;
  setViewportSize(params: PageSetViewportSizeParams): Promise<PageSetViewportSizeResult>;
  keyboardDown(params: PageKeyboardDownParams): Promise<PageKeyboardDownResult>;
  keyboardUp(params: PageKeyboardUpParams): Promise<PageKeyboardUpResult>;
  keyboardInsertText(params: PageKeyboardInsertTextParams): Promise<PageKeyboardInsertTextResult>;
  keyboardType(params: PageKeyboardTypeParams): Promise<PageKeyboardTypeResult>;
  keyboardPress(params: PageKeyboardPressParams): Promise<PageKeyboardPressResult>;
  mouseMove(params: PageMouseMoveParams): Promise<PageMouseMoveResult>;
  mouseDown(params: PageMouseDownParams): Promise<PageMouseDownResult>;
  mouseUp(params: PageMouseUpParams): Promise<PageMouseUpResult>;
  mouseClick(params: PageMouseClickParams): Promise<PageMouseClickResult>;
  accessibilitySnapshot(params: PageAccessibilitySnapshotParams): Promise<PageAccessibilitySnapshotResult>;
  pdf(params: PagePdfParams): Promise<PagePdfResult>;
  crStartJSCoverage(params: PageCrStartJSCoverageParams): Promise<PageCrStartJSCoverageResult>;
  crStopJSCoverage(params?: PageCrStopJSCoverageParams): Promise<PageCrStopJSCoverageResult>;
  crStartCSSCoverage(params: PageCrStartCSSCoverageParams): Promise<PageCrStartCSSCoverageResult>;
  crStopCSSCoverage(params?: PageCrStopCSSCoverageParams): Promise<PageCrStopCSSCoverageResult>;
  bringToFront(params?: PageBringToFrontParams): Promise<PageBringToFrontResult>;
}
export type PageBindingCallEvent = {
  binding: BindingCallChannel,
};
export type PageCloseEvent = {};
export type PageConsoleEvent = {
  message: ConsoleMessageChannel,
};
export type PageCrashEvent = {};
export type PageDialogEvent = {
  dialog: DialogChannel,
};
export type PageDownloadEvent = {
  download: DownloadChannel,
};
export type PageDomcontentloadedEvent = {};
export type PageFileChooserEvent = {
  element: ElementHandleChannel,
  isMultiple: boolean,
};
export type PageFrameAttachedEvent = {
  frame: FrameChannel,
};
export type PageFrameDetachedEvent = {
  frame: FrameChannel,
};
export type PageLoadEvent = {};
export type PagePageErrorEvent = {
  error: SerializedError,
};
export type PagePopupEvent = {
  page: PageChannel,
};
export type PageRequestEvent = {
  request: RequestChannel,
};
export type PageRequestFailedEvent = {
  request: RequestChannel,
  failureText?: string,
};
export type PageRequestFinishedEvent = {
  request: RequestChannel,
};
export type PageResponseEvent = {
  response: ResponseChannel,
};
export type PageRouteEvent = {
  route: RouteChannel,
  request: RequestChannel,
};
export type PageWorkerEvent = {
  worker: WorkerChannel,
};
export type PageSetDefaultNavigationTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultNavigationTimeoutNoReplyResult = void;
export type PageSetDefaultTimeoutNoReplyParams = {
  timeout: number,
};
export type PageSetDefaultTimeoutNoReplyResult = void;
export type PageSetFileChooserInterceptedNoReplyParams = {
  intercepted: boolean,
};
export type PageSetFileChooserInterceptedNoReplyResult = void;
export type PageAddInitScriptParams = {
  source: string,
};
export type PageAddInitScriptResult = void;
export type PageCloseParams = {
  runBeforeUnload?: boolean,
};
export type PageCloseResult = void;
export type PageEmulateMediaParams = {
  media?: 'screen' | 'print',
  colorScheme?: 'dark' | 'light' | 'no-preference',
};
export type PageEmulateMediaResult = void;
export type PageExposeBindingParams = {
  name: string,
};
export type PageExposeBindingResult = void;
export type PageGoBackParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoBackResult = {
  response?: ResponseChannel,
};
export type PageGoForwardParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageGoForwardResult = {
  response?: ResponseChannel,
};
export type PageOpenerParams = {};
export type PageOpenerResult = {
  page?: PageChannel,
};
export type PageReloadParams = {
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type PageReloadResult = {
  response?: ResponseChannel,
};
export type PageScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  path?: string,
  quality?: number,
  omitBackground?: boolean,
  fullPage?: boolean,
  clip?: {
    width: number,
    height: number,
    x: number,
    y: number,
  },
};
export type PageScreenshotResult = {
  binary: Binary,
};
export type PageSetExtraHTTPHeadersParams = {
  headers: {
    name: string,
    value: string,
  }[],
};
export type PageSetExtraHTTPHeadersResult = void;
export type PageSetNetworkInterceptionEnabledParams = {
  enabled: boolean,
};
export type PageSetNetworkInterceptionEnabledResult = void;
export type PageSetViewportSizeParams = {
  viewportSize: {
    width: number,
    height: number,
  },
};
export type PageSetViewportSizeResult = void;
export type PageKeyboardDownParams = {
  key: string,
};
export type PageKeyboardDownResult = void;
export type PageKeyboardUpParams = {
  key: string,
};
export type PageKeyboardUpResult = void;
export type PageKeyboardInsertTextParams = {
  text: string,
};
export type PageKeyboardInsertTextResult = void;
export type PageKeyboardTypeParams = {
  text: string,
  delay?: number,
};
export type PageKeyboardTypeResult = void;
export type PageKeyboardPressParams = {
  key: string,
  delay?: number,
};
export type PageKeyboardPressResult = void;
export type PageMouseMoveParams = {
  x: number,
  y: number,
  steps?: number,
};
export type PageMouseMoveResult = void;
export type PageMouseDownParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseDownResult = void;
export type PageMouseUpParams = {
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseUpResult = void;
export type PageMouseClickParams = {
  x: number,
  y: number,
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
};
export type PageMouseClickResult = void;
export type PageAccessibilitySnapshotParams = {
  interestingOnly?: boolean,
  root?: ElementHandleChannel,
};
export type PageAccessibilitySnapshotResult = {
  rootAXNode?: AXNode,
};
export type PagePdfParams = {
  scale?: number,
  displayHeaderFooter?: boolean,
  headerTemplate?: string,
  footerTemplate?: string,
  printBackground?: boolean,
  landscape?: boolean,
  pageRanges?: string,
  format?: string,
  width?: string,
  height?: string,
  preferCSSPageSize?: boolean,
  margin?: {
    top?: string,
    bottom?: string,
    left?: string,
    right?: string,
  },
};
export type PagePdfResult = {
  pdf: Binary,
};
export type PageCrStartJSCoverageParams = {
  resetOnNavigation?: boolean,
  reportAnonymousScripts?: boolean,
};
export type PageCrStartJSCoverageResult = void;
export type PageCrStopJSCoverageParams = {};
export type PageCrStopJSCoverageResult = {
  entries: {
    url: string,
    scriptId: string,
    source?: string,
    functions: {
      functionName: string,
      isBlockCoverage: boolean,
      ranges: {
        startOffset: number,
        endOffset: number,
        count: number,
      }[],
    }[],
  }[],
};
export type PageCrStartCSSCoverageParams = {
  resetOnNavigation?: boolean,
};
export type PageCrStartCSSCoverageResult = void;
export type PageCrStopCSSCoverageParams = {};
export type PageCrStopCSSCoverageResult = {
  entries: {
    url: string,
    text?: string,
    ranges: {
      start: number,
      end: number,
    }[],
  }[],
};
export type PageBringToFrontParams = {};
export type PageBringToFrontResult = void;

// ----------- Frame -----------
export type FrameInitializer = {
  url: string,
  name: string,
  parentFrame?: FrameChannel,
  loadStates: ('load' | 'domcontentloaded' | 'networkidle')[],
};
export interface FrameChannel extends Channel {
  on(event: 'loadstate', callback: (params: FrameLoadstateEvent) => void): this;
  on(event: 'navigated', callback: (params: FrameNavigatedEvent) => void): this;
  evalOnSelector(params: FrameEvalOnSelectorParams): Promise<FrameEvalOnSelectorResult>;
  evalOnSelectorAll(params: FrameEvalOnSelectorAllParams): Promise<FrameEvalOnSelectorAllResult>;
  addScriptTag(params: FrameAddScriptTagParams): Promise<FrameAddScriptTagResult>;
  addStyleTag(params: FrameAddStyleTagParams): Promise<FrameAddStyleTagResult>;
  check(params: FrameCheckParams): Promise<FrameCheckResult>;
  click(params: FrameClickParams): Promise<FrameClickResult>;
  content(params?: FrameContentParams): Promise<FrameContentResult>;
  dblclick(params: FrameDblclickParams): Promise<FrameDblclickResult>;
  dispatchEvent(params: FrameDispatchEventParams): Promise<FrameDispatchEventResult>;
  evaluateExpression(params: FrameEvaluateExpressionParams): Promise<FrameEvaluateExpressionResult>;
  evaluateExpressionHandle(params: FrameEvaluateExpressionHandleParams): Promise<FrameEvaluateExpressionHandleResult>;
  fill(params: FrameFillParams): Promise<FrameFillResult>;
  focus(params: FrameFocusParams): Promise<FrameFocusResult>;
  frameElement(params?: FrameFrameElementParams): Promise<FrameFrameElementResult>;
  getAttribute(params: FrameGetAttributeParams): Promise<FrameGetAttributeResult>;
  goto(params: FrameGotoParams): Promise<FrameGotoResult>;
  hover(params: FrameHoverParams): Promise<FrameHoverResult>;
  innerHTML(params: FrameInnerHTMLParams): Promise<FrameInnerHTMLResult>;
  innerText(params: FrameInnerTextParams): Promise<FrameInnerTextResult>;
  press(params: FramePressParams): Promise<FramePressResult>;
  querySelector(params: FrameQuerySelectorParams): Promise<FrameQuerySelectorResult>;
  querySelectorAll(params: FrameQuerySelectorAllParams): Promise<FrameQuerySelectorAllResult>;
  selectOption(params: FrameSelectOptionParams): Promise<FrameSelectOptionResult>;
  setContent(params: FrameSetContentParams): Promise<FrameSetContentResult>;
  setInputFiles(params: FrameSetInputFilesParams): Promise<FrameSetInputFilesResult>;
  textContent(params: FrameTextContentParams): Promise<FrameTextContentResult>;
  title(params?: FrameTitleParams): Promise<FrameTitleResult>;
  type(params: FrameTypeParams): Promise<FrameTypeResult>;
  uncheck(params: FrameUncheckParams): Promise<FrameUncheckResult>;
  waitForFunction(params: FrameWaitForFunctionParams): Promise<FrameWaitForFunctionResult>;
  waitForSelector(params: FrameWaitForSelectorParams): Promise<FrameWaitForSelectorResult>;
}
export type FrameLoadstateEvent = {
  add?: 'load' | 'domcontentloaded' | 'networkidle',
  remove?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameNavigatedEvent = {
  url: string,
  name: string,
  newDocument?: {
    request?: RequestChannel,
  },
  error?: string,
};
export type FrameEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type FrameEvalOnSelectorResult = {
  value: SerializedValue,
};
export type FrameEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type FrameEvalOnSelectorAllResult = {
  value: SerializedValue,
};
export type FrameAddScriptTagParams = {
  url?: string,
  content?: string,
  type?: string,
};
export type FrameAddScriptTagResult = {
  element: ElementHandleChannel,
};
export type FrameAddStyleTagParams = {
  url?: string,
  content?: string,
};
export type FrameAddStyleTagResult = {
  element: ElementHandleChannel,
};
export type FrameCheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameCheckResult = void;
export type FrameClickParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: {
    x: number,
    y: number,
  },
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type FrameClickResult = void;
export type FrameContentParams = {};
export type FrameContentResult = {
  value: string,
};
export type FrameDblclickParams = {
  selector: string,
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: {
    x: number,
    y: number,
  },
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type FrameDblclickResult = void;
export type FrameDispatchEventParams = {
  selector: string,
  type: string,
  eventInit: SerializedArgument,
  timeout?: number,
};
export type FrameDispatchEventResult = void;
export type FrameEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type FrameEvaluateExpressionResult = {
  value: SerializedValue,
};
export type FrameEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type FrameEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type FrameFillParams = {
  selector: string,
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameFillResult = void;
export type FrameFocusParams = {
  selector: string,
  timeout?: number,
};
export type FrameFocusResult = void;
export type FrameFrameElementParams = {};
export type FrameFrameElementResult = {
  element: ElementHandleChannel,
};
export type FrameGetAttributeParams = {
  selector: string,
  name: string,
  timeout?: number,
};
export type FrameGetAttributeResult = {
  value?: string,
};
export type FrameGotoParams = {
  url: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
  referer?: string,
};
export type FrameGotoResult = {
  response?: ResponseChannel,
};
export type FrameHoverParams = {
  selector: string,
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: {
    x: number,
    y: number,
  },
  timeout?: number,
};
export type FrameHoverResult = void;
export type FrameInnerHTMLParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerHTMLResult = {
  value: string,
};
export type FrameInnerTextParams = {
  selector: string,
  timeout?: number,
};
export type FrameInnerTextResult = {
  value: string,
};
export type FramePressParams = {
  selector: string,
  key: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FramePressResult = void;
export type FrameQuerySelectorParams = {
  selector: string,
};
export type FrameQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type FrameQuerySelectorAllParams = {
  selector: string,
};
export type FrameQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type FrameSelectOptionParams = {
  selector: string,
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSelectOptionResult = {
  values: string[],
};
export type FrameSetContentParams = {
  html: string,
  timeout?: number,
  waitUntil?: 'load' | 'domcontentloaded' | 'networkidle',
};
export type FrameSetContentResult = void;
export type FrameSetInputFilesParams = {
  selector: string,
  files: {
    name: string,
    mimeType: string,
    buffer: string,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type FrameSetInputFilesResult = void;
export type FrameTextContentParams = {
  selector: string,
  timeout?: number,
};
export type FrameTextContentResult = {
  value?: string,
};
export type FrameTitleParams = {};
export type FrameTitleResult = {
  value: string,
};
export type FrameTypeParams = {
  selector: string,
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameTypeResult = void;
export type FrameUncheckParams = {
  selector: string,
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type FrameUncheckResult = void;
export type FrameWaitForFunctionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
  timeout?: number,
  pollingInterval?: number,
};
export type FrameWaitForFunctionResult = {
  handle: JSHandleChannel,
};
export type FrameWaitForSelectorParams = {
  selector: string,
  timeout?: number,
  state?: 'attached' | 'detached' | 'visible' | 'hidden',
};
export type FrameWaitForSelectorResult = {
  element?: ElementHandleChannel,
};

// ----------- Worker -----------
export type WorkerInitializer = {
  url: string,
};
export interface WorkerChannel extends Channel {
  evaluateExpression(params: WorkerEvaluateExpressionParams): Promise<WorkerEvaluateExpressionResult>;
  evaluateExpressionHandle(params: WorkerEvaluateExpressionHandleParams): Promise<WorkerEvaluateExpressionHandleResult>;
}
export type WorkerEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type WorkerEvaluateExpressionResult = {
  value: SerializedValue,
};
export type WorkerEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type WorkerEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};

// ----------- JSHandle -----------
export type JSHandleInitializer = {
  preview: string,
};
export interface JSHandleChannel extends Channel {
  on(event: 'previewUpdated', callback: (params: JSHandlePreviewUpdatedEvent) => void): this;
  dispose(params?: JSHandleDisposeParams): Promise<JSHandleDisposeResult>;
  evaluateExpression(params: JSHandleEvaluateExpressionParams): Promise<JSHandleEvaluateExpressionResult>;
  evaluateExpressionHandle(params: JSHandleEvaluateExpressionHandleParams): Promise<JSHandleEvaluateExpressionHandleResult>;
  getPropertyList(params?: JSHandleGetPropertyListParams): Promise<JSHandleGetPropertyListResult>;
  getProperty(params: JSHandleGetPropertyParams): Promise<JSHandleGetPropertyResult>;
  jsonValue(params?: JSHandleJsonValueParams): Promise<JSHandleJsonValueResult>;
}
export type JSHandlePreviewUpdatedEvent = {
  preview: string,
};
export type JSHandleDisposeParams = {};
export type JSHandleDisposeResult = void;
export type JSHandleEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type JSHandleEvaluateExpressionResult = {
  value: SerializedValue,
};
export type JSHandleEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type JSHandleEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type JSHandleGetPropertyListParams = {};
export type JSHandleGetPropertyListResult = {
  properties: {
    name: string,
    value: JSHandleChannel,
  }[],
};
export type JSHandleGetPropertyParams = {
  name: string,
};
export type JSHandleGetPropertyResult = {
  handle: JSHandleChannel,
};
export type JSHandleJsonValueParams = {};
export type JSHandleJsonValueResult = {
  value: SerializedValue,
};

// ----------- ElementHandle -----------
export type ElementHandleInitializer = {};
export interface ElementHandleChannel extends JSHandleChannel {
  evalOnSelector(params: ElementHandleEvalOnSelectorParams): Promise<ElementHandleEvalOnSelectorResult>;
  evalOnSelectorAll(params: ElementHandleEvalOnSelectorAllParams): Promise<ElementHandleEvalOnSelectorAllResult>;
  boundingBox(params?: ElementHandleBoundingBoxParams): Promise<ElementHandleBoundingBoxResult>;
  check(params: ElementHandleCheckParams): Promise<ElementHandleCheckResult>;
  click(params: ElementHandleClickParams): Promise<ElementHandleClickResult>;
  contentFrame(params?: ElementHandleContentFrameParams): Promise<ElementHandleContentFrameResult>;
  dblclick(params: ElementHandleDblclickParams): Promise<ElementHandleDblclickResult>;
  dispatchEvent(params: ElementHandleDispatchEventParams): Promise<ElementHandleDispatchEventResult>;
  fill(params: ElementHandleFillParams): Promise<ElementHandleFillResult>;
  focus(params?: ElementHandleFocusParams): Promise<ElementHandleFocusResult>;
  getAttribute(params: ElementHandleGetAttributeParams): Promise<ElementHandleGetAttributeResult>;
  hover(params: ElementHandleHoverParams): Promise<ElementHandleHoverResult>;
  innerHTML(params?: ElementHandleInnerHTMLParams): Promise<ElementHandleInnerHTMLResult>;
  innerText(params?: ElementHandleInnerTextParams): Promise<ElementHandleInnerTextResult>;
  ownerFrame(params?: ElementHandleOwnerFrameParams): Promise<ElementHandleOwnerFrameResult>;
  press(params: ElementHandlePressParams): Promise<ElementHandlePressResult>;
  querySelector(params: ElementHandleQuerySelectorParams): Promise<ElementHandleQuerySelectorResult>;
  querySelectorAll(params: ElementHandleQuerySelectorAllParams): Promise<ElementHandleQuerySelectorAllResult>;
  screenshot(params: ElementHandleScreenshotParams): Promise<ElementHandleScreenshotResult>;
  scrollIntoViewIfNeeded(params: ElementHandleScrollIntoViewIfNeededParams): Promise<ElementHandleScrollIntoViewIfNeededResult>;
  selectOption(params: ElementHandleSelectOptionParams): Promise<ElementHandleSelectOptionResult>;
  selectText(params: ElementHandleSelectTextParams): Promise<ElementHandleSelectTextResult>;
  setInputFiles(params: ElementHandleSetInputFilesParams): Promise<ElementHandleSetInputFilesResult>;
  textContent(params?: ElementHandleTextContentParams): Promise<ElementHandleTextContentResult>;
  type(params: ElementHandleTypeParams): Promise<ElementHandleTypeResult>;
  uncheck(params: ElementHandleUncheckParams): Promise<ElementHandleUncheckResult>;
}
export type ElementHandleEvalOnSelectorParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElementHandleEvalOnSelectorResult = {
  value: SerializedValue,
};
export type ElementHandleEvalOnSelectorAllParams = {
  selector: string,
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElementHandleEvalOnSelectorAllResult = {
  value: SerializedValue,
};
export type ElementHandleBoundingBoxParams = {};
export type ElementHandleBoundingBoxResult = {
  value?: {
    width: number,
    height: number,
    x: number,
    y: number,
  },
};
export type ElementHandleCheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleCheckResult = void;
export type ElementHandleClickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: {
    x: number,
    y: number,
  },
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  clickCount?: number,
  timeout?: number,
};
export type ElementHandleClickResult = void;
export type ElementHandleContentFrameParams = {};
export type ElementHandleContentFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandleDblclickParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: {
    x: number,
    y: number,
  },
  delay?: number,
  button?: 'left' | 'right' | 'middle',
  timeout?: number,
};
export type ElementHandleDblclickResult = void;
export type ElementHandleDispatchEventParams = {
  type: string,
  eventInit: SerializedArgument,
};
export type ElementHandleDispatchEventResult = void;
export type ElementHandleFillParams = {
  value: string,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleFillResult = void;
export type ElementHandleFocusParams = {};
export type ElementHandleFocusResult = void;
export type ElementHandleGetAttributeParams = {
  name: string,
};
export type ElementHandleGetAttributeResult = {
  value?: string,
};
export type ElementHandleHoverParams = {
  force?: boolean,
  modifiers?: ('Alt' | 'Control' | 'Meta' | 'Shift')[],
  position?: {
    x: number,
    y: number,
  },
  timeout?: number,
};
export type ElementHandleHoverResult = void;
export type ElementHandleInnerHTMLParams = {};
export type ElementHandleInnerHTMLResult = {
  value: string,
};
export type ElementHandleInnerTextParams = {};
export type ElementHandleInnerTextResult = {
  value: string,
};
export type ElementHandleOwnerFrameParams = {};
export type ElementHandleOwnerFrameResult = {
  frame?: FrameChannel,
};
export type ElementHandlePressParams = {
  key: string,
  delay?: number,
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandlePressResult = void;
export type ElementHandleQuerySelectorParams = {
  selector: string,
};
export type ElementHandleQuerySelectorResult = {
  element?: ElementHandleChannel,
};
export type ElementHandleQuerySelectorAllParams = {
  selector: string,
};
export type ElementHandleQuerySelectorAllResult = {
  elements: ElementHandleChannel[],
};
export type ElementHandleScreenshotParams = {
  timeout?: number,
  type?: 'png' | 'jpeg',
  path?: string,
  quality?: number,
  omitBackground?: boolean,
};
export type ElementHandleScreenshotResult = {
  binary: Binary,
};
export type ElementHandleScrollIntoViewIfNeededParams = {
  timeout?: number,
};
export type ElementHandleScrollIntoViewIfNeededResult = void;
export type ElementHandleSelectOptionParams = {
  elements?: ElementHandleChannel[],
  options?: {
    value?: string,
    label?: string,
    index?: number,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSelectOptionResult = {
  values: string[],
};
export type ElementHandleSelectTextParams = {
  timeout?: number,
};
export type ElementHandleSelectTextResult = void;
export type ElementHandleSetInputFilesParams = {
  files: {
    name: string,
    mimeType: string,
    buffer: string,
  }[],
  timeout?: number,
  noWaitAfter?: boolean,
};
export type ElementHandleSetInputFilesResult = void;
export type ElementHandleTextContentParams = {};
export type ElementHandleTextContentResult = {
  value?: string,
};
export type ElementHandleTypeParams = {
  text: string,
  delay?: number,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleTypeResult = void;
export type ElementHandleUncheckParams = {
  force?: boolean,
  noWaitAfter?: boolean,
  timeout?: number,
};
export type ElementHandleUncheckResult = void;

// ----------- Request -----------
export type RequestInitializer = {
  frame: FrameChannel,
  url: string,
  resourceType: string,
  method: string,
  postData?: string,
  headers: {
    name: string,
    value: string,
  }[],
  isNavigationRequest: boolean,
  redirectedFrom?: RequestChannel,
};
export interface RequestChannel extends Channel {
  response(params?: RequestResponseParams): Promise<RequestResponseResult>;
}
export type RequestResponseParams = {};
export type RequestResponseResult = {
  response?: ResponseChannel,
};

// ----------- Route -----------
export type RouteInitializer = {
  request: RequestChannel,
};
export interface RouteChannel extends Channel {
  abort(params: RouteAbortParams): Promise<RouteAbortResult>;
  continue(params: RouteContinueParams): Promise<RouteContinueResult>;
  fulfill(params: RouteFulfillParams): Promise<RouteFulfillResult>;
}
export type RouteAbortParams = {
  errorCode: string,
};
export type RouteAbortResult = void;
export type RouteContinueParams = {
  method?: string,
  headers?: {
    name: string,
    value: string,
  }[],
  postData?: string,
};
export type RouteContinueResult = void;
export type RouteFulfillParams = {
  status: number,
  headers: {
    name: string,
    value: string,
  }[],
  body: string,
  isBase64: boolean,
};
export type RouteFulfillResult = void;

// ----------- Response -----------
export type ResponseInitializer = {
  request: RequestChannel,
  url: string,
  status: number,
  statusText: string,
  headers: {
    name: string,
    value: string,
  }[],
};
export interface ResponseChannel extends Channel {
  body(params?: ResponseBodyParams): Promise<ResponseBodyResult>;
  finished(params?: ResponseFinishedParams): Promise<ResponseFinishedResult>;
}
export type ResponseBodyParams = {};
export type ResponseBodyResult = {
  binary: Binary,
};
export type ResponseFinishedParams = {};
export type ResponseFinishedResult = {
  error?: string,
};

// ----------- ConsoleMessage -----------
export type ConsoleMessageInitializer = {
  type: string,
  text: string,
  args: JSHandleChannel[],
  location: {
    url?: string,
    lineNumber?: number,
    columnNumber?: number,
  },
};
export interface ConsoleMessageChannel extends Channel {
}

// ----------- BindingCall -----------
export type BindingCallInitializer = {
  frame: FrameChannel,
  name: string,
  args: SerializedValue[],
};
export interface BindingCallChannel extends Channel {
  reject(params: BindingCallRejectParams): Promise<BindingCallRejectResult>;
  resolve(params: BindingCallResolveParams): Promise<BindingCallResolveResult>;
}
export type BindingCallRejectParams = {
  error: SerializedError,
};
export type BindingCallRejectResult = void;
export type BindingCallResolveParams = {
  result: SerializedArgument,
};
export type BindingCallResolveResult = void;

// ----------- Dialog -----------
export type DialogInitializer = {
  type: string,
  message: string,
  defaultValue: string,
};
export interface DialogChannel extends Channel {
  accept(params: DialogAcceptParams): Promise<DialogAcceptResult>;
  dismiss(params?: DialogDismissParams): Promise<DialogDismissResult>;
}
export type DialogAcceptParams = {
  promptText?: string,
};
export type DialogAcceptResult = void;
export type DialogDismissParams = {};
export type DialogDismissResult = void;

// ----------- Download -----------
export type DownloadInitializer = {
  url: string,
  suggestedFilename: string,
};
export interface DownloadChannel extends Channel {
  path(params?: DownloadPathParams): Promise<DownloadPathResult>;
  saveAs(params: DownloadSaveAsParams): Promise<DownloadSaveAsResult>;
  failure(params?: DownloadFailureParams): Promise<DownloadFailureResult>;
  stream(params?: DownloadStreamParams): Promise<DownloadStreamResult>;
  delete(params?: DownloadDeleteParams): Promise<DownloadDeleteResult>;
}
export type DownloadPathParams = {};
export type DownloadPathResult = {
  value?: string,
};
export type DownloadSaveAsParams = {
  path: string,
};
export type DownloadSaveAsResult = void;
export type DownloadFailureParams = {};
export type DownloadFailureResult = {
  error?: string,
};
export type DownloadStreamParams = {};
export type DownloadStreamResult = {
  stream?: StreamChannel,
};
export type DownloadDeleteParams = {};
export type DownloadDeleteResult = void;

// ----------- Stream -----------
export type StreamInitializer = {};
export interface StreamChannel extends Channel {
  read(params: StreamReadParams): Promise<StreamReadResult>;
}
export type StreamReadParams = {
  size?: number,
};
export type StreamReadResult = {
  binary: Binary,
};

// ----------- CDPSession -----------
export type CDPSessionInitializer = {};
export interface CDPSessionChannel extends Channel {
  on(event: 'event', callback: (params: CDPSessionEventEvent) => void): this;
  on(event: 'disconnected', callback: (params: CDPSessionDisconnectedEvent) => void): this;
  send(params: CDPSessionSendParams): Promise<CDPSessionSendResult>;
  detach(params?: CDPSessionDetachParams): Promise<CDPSessionDetachResult>;
}
export type CDPSessionEventEvent = {
  method: string,
  params?: SerializedValue,
};
export type CDPSessionDisconnectedEvent = {};
export type CDPSessionSendParams = {
  method: string,
  params?: SerializedValue,
};
export type CDPSessionSendResult = {
  result: SerializedValue,
};
export type CDPSessionDetachParams = {};
export type CDPSessionDetachResult = void;

// ----------- Electron -----------
export type ElectronInitializer = {};
export interface ElectronChannel extends Channel {
  launch(params: ElectronLaunchParams): Promise<ElectronLaunchResult>;
}
export type ElectronLaunchParams = {
  executablePath: string,
  args?: string[],
  cwd?: string,
  env?: {
    name: string,
    value: string,
  }[],
  handleSIGINT?: boolean,
  handleSIGTERM?: boolean,
  handleSIGHUP?: boolean,
  timeout?: number,
};
export type ElectronLaunchResult = {
  electronApplication: ElectronApplicationChannel,
};

// ----------- ElectronApplication -----------
export type ElectronApplicationInitializer = {
  context: BrowserContextChannel,
};
export interface ElectronApplicationChannel extends Channel {
  on(event: 'close', callback: (params: ElectronApplicationCloseEvent) => void): this;
  on(event: 'window', callback: (params: ElectronApplicationWindowEvent) => void): this;
  newBrowserWindow(params: ElectronApplicationNewBrowserWindowParams): Promise<ElectronApplicationNewBrowserWindowResult>;
  evaluateExpression(params: ElectronApplicationEvaluateExpressionParams): Promise<ElectronApplicationEvaluateExpressionResult>;
  evaluateExpressionHandle(params: ElectronApplicationEvaluateExpressionHandleParams): Promise<ElectronApplicationEvaluateExpressionHandleResult>;
  close(params?: ElectronApplicationCloseParams): Promise<ElectronApplicationCloseResult>;
}
export type ElectronApplicationCloseEvent = {};
export type ElectronApplicationWindowEvent = {
  page: PageChannel,
  browserWindow: JSHandleChannel,
};
export type ElectronApplicationNewBrowserWindowParams = {
  arg: SerializedArgument,
};
export type ElectronApplicationNewBrowserWindowResult = {
  page: PageChannel,
};
export type ElectronApplicationEvaluateExpressionParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionResult = {
  value: SerializedValue,
};
export type ElectronApplicationEvaluateExpressionHandleParams = {
  expression: string,
  isFunction: boolean,
  arg: SerializedArgument,
};
export type ElectronApplicationEvaluateExpressionHandleResult = {
  handle: JSHandleChannel,
};
export type ElectronApplicationCloseParams = {};
export type ElectronApplicationCloseResult = void;
